# -*- coding: utf-8 -*-
"""Notebook.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/AI-Core/Content-Public/blob/main/Content/units/Essentials/7.%20Python%20programming/16.%20Defining%20Functions/Notebook.ipynb

# Functions
"""





"""## Learning Objectives
- Understand functions.
- Learn how to define a function.
- Understand the basic difference between functions and methods.
- Understand arguments and outputs.
- Learn how to use the help() function.
- Understand the concepts of scope and recursion.

## Introduction

- Functions comprise a block of code that only runs when called.
- They enable us to avoid redefining repetitive operations.
- Similar to For loops, functions allow us to adhere to the DRY principle.

## Defining Functions

- A function accepts parameters and can return an output.
- The value passed in as a parameter is called an **argument**.
- A function associated with an object is called a method.
- An instance of a function is called a function call. <br><br>
The basic syntax of a function is as follows:
"""

# function definition
def function_name (param1, param2 = 1):
    '''
    DOCSTRING: explains function
    INPUT: Name (str)
    OUTPUT: Hello Name (str)
    '''
    # add code to run
    return("Hello " + param1)

# function call
function_name("Zain")

function_name

"""- The __def__ keyword notifies python that a function is about to be defined.
- __Function name__, as implied, refers to the name of the function (all in lower case, separated by an underscore; built-in keywords should not be used (see PEP8 for details)).
- __Parameters__, in parentheses, are the passed-in values.
- __Default arguments__ are arguments that have a default value to revert to if no other value is specified. Here, param2 = 1 indicates that param2 will be 1, unless otherwise specified in the function call.
- __Colon__ indicates the end of the definition line; the next line will be indented.
- __Docstrings__ explain what the function is doing (read PEP257 or google __*'python docstrings'*__ for guidelines; https://www.python.org/dev/peps/pep-0257/).
- The __Return__ keyword indicates the output of the function.
<br><br>

Things to note. 
- When performing a function call, the name of the function should be written, followed by parentheses containing the arguments to be passed.
- If a function is called without parentheses, it will not run! It will simply display some information on the function, including the module it belongs to, its name, and the parameters it accepts.

## The help() Function

- The help() function is used to find the documentation of a function.
- The keyboard shortcut for this is Shift + Tab.
- For more detailed information, find and use the full function documentation on Google.
"""

help(function_name)

x = 0
def func(x):
    x = x + 1
    return x

func(x)

help(print)

"""## Variable Scope

- Variable scope refers to the sections in a program in which a variable can be referenced.
- There are two kinds of variable scopes: local and global.
- A variable defined in a function can only be referenced within that function: local scope.
- A variable defined outside a function (in the general script) can be referenced within the function; however, it cannot be modified from within the function (UnboundLocalError).
- To modify it within the function, it must be redefined within the function.
"""

counter = 0 # Global scope

def add_to_counter():
    counter = 12
    output = counter # Local scope
    return output # When calling for the function, the returned value will correspond to what is included in this statement.

x = add_to_counter()
print(x) 
print(counter) # The local scope does not change the global scope.

counter = 0 # Global scope

def add_to_counter():
    counter = 12 # Local scope
    return counter # When calling for the function, the returned value will correspond to what is included in this statement.

x = add_to_counter()
print(x) 
print(counter) # The local scope does not change the global scope.

"""Although the global scope affects the local scope, it does not mean that the global variable is actually within the function. In the below example, global counter affects the value of local counter; however, if it is used before it is defined in the function, it will not work. This is because the function does not know whether to use the local or global scope."""

counter = 0

def add_to_counter():
    counter = counter + 1
    return counter

counter = add_to_counter()

print(counter)

"""Here, the value of counter is known, even though it has not been defined."""

counter = 0

def add_to_counter():
    x = counter + 1
    return x

counter = add_to_counter()

print(counter)

"""To modify the global scope from within a function, the global keyword can be used."""

counter = 0

def add_to_counter():
    global counter
    counter += 12 # add 12 to counter
    return counter

add_to_counter()
print(counter)

"""Functions can accept an indefinite number of arguments. However, if the number of arguments varies, the * and ** operators can be introduced as inputs for the function."""

def fun_dummy(*args, **kwargs): # args = arguments, kwargs = key word arguments
    print(args) # args is now a tuple
    print(kwargs) # kwargs now is a dictionary

fun_dummy(1, 2, 3, 5, 6, 2, 1, a=4, b=5, c=6)
# anything without a keyword argument (by keyword, we mean a, b, c) will be a tuple in the function.
# Anything with a keyword argument will be included in a dictionary in the function.

"""In the following example, an undefined number of arguments is passed to a function to perform a sum operation:"""

def sum_args(*args):
    print(f'args is a tuple {args}')
    return sum(args)


print(sum_args(1, 42, 4.2))  # You can add as many arguments as you want.
print(sum_args(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1))

"""When passing **kwargs, kwargs can serve as a dictionary, which can be iterated over."""

new_dict = {'a': 5, 'b': 3, 'c': 6}

x, y = (1, 2)

new_dict.items()

def keys_and_values(**kwargs):
    print(f'kwargs is a dictionary: {kwargs}')
    for key, value in kwargs.items():
        print(f'Key is {key} and its value is {value}')

keys_and_values(a=5, b=3, c=6)

"""If a regular argument is passed to a function that only accepts keyword arguments, it will throw an error."""

def addition(x, y):
    print(x + y)

addition(1, 5)

def keys_and_values(*args, **kwargs):
    print(f'kwargs is a dictionary: {kwargs}')
    for key, value in kwargs.items():
        print(f'Key is {key} and its value is {value}')

keys_and_values(5, a=5, b=3, c=6)

"""The same applies for the opposite.

"""

def sum_args(*args):
    print(f'args is a tuple {args}')
    return sum(args)

x = sum_args(c=1, d=2)

"""When positional arguments are passed, they must come first, followed by keyword arguments.

"""

def fun_dummy(*args, **kwargs):  # args = arguments, kwargs = key word arguments
    print(args)  # args is now a tuple
    print(kwargs)  # kwargs is now a dictionary


fun_dummy(1, 2, e=4, d=4, c=6, e=5)

"""## Recursion

- A recursive function is one that calls itself within its definition.
- This can be difficult to grasp at first; however, think of it as breaking down a large problem into a relatively small problem repeatedly.
- This indicates that a complex problem can be made increasingly simple by repeatedly addressing a simpler form of the same problem with each repetition.
- However, the 'simplest form' of the function must be provided where the function stops; otherwise, it will repeat forever and throw an error.
- This 'simplest form' is called a base case.
- This is best illustrated with an example:
"""

# A function that takes in the starting number to countdown from as the input 
def countdown(n):
    
    # base case: this is where the function will eventually stop
    if n == 0:
        print(0)
        
    # Here, we reduce the problem to a simpler version.
    else:
        
        # We print the countdown number.
        print(n)
        
        # We repeat the function with the next smallest number.
        countdown(n-1)
        

countdown(5)

"""## Conclusion


At this point, you should have a good understanding of
- functions in Python.
- variable scope.
- the concept of recursion.
- how to define a function.
- how to call a function.
- how to use the help() function.
- how to use recursive functions.

## Further Reading
- Python Function Definitions: https://docs.python.org/3/reference/compound_stmts.html#function-definitions
- Python Docstring Conventions: https://www.python.org/dev/peps/pep-0257/
"""