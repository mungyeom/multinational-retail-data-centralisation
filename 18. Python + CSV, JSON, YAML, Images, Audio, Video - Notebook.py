# -*- coding: utf-8 -*-
"""Notebook.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/AI-Core/Content-Public/blob/main/Content/units/Data-Handling/0.%20Accessing%20Different%20Data%20Formats%20in%20Python/0.%20Python%20%2B%20CSV%2C%20JSON%2C%20YAML%2C%20Images%2C%20Audio%2C%20Video/Notebook.ipynb

# Data and File Formats

When working in projects involved in AI, most likely you will need to deal with different data and file formats including:
- CSV
- JSON
- YAML
- Images
- Videos
- Audio

In this notebook, we will briefly introduce each one of them, as well as give some comments on how and when to use them.

We are going to work with some files with the data formats we mentioned, so before start reading the notebook, make sure to run the following cell to download the necessary files
"""

!wget "https://aicore-files.s3.amazonaws.com/Foundations/Data_Formats/Salaries.csv" "https://aicore-files.s3.amazonaws.com/Foundations/Data_Formats/employees.xml" "https://aicore-files.s3.amazonaws.com/Foundations/Data_Formats/JSON_sample.json" "https://aicore-files.s3.amazonaws.com/Foundations/Data_Formats/yaml_example.yaml"

"""## CSV

> <font size=+1> CSV __(comma-separated values)__ files contain rows of data, with each value in a row separated by a comma

- They are a very common way to store data </font>
- All of the data for a single record is on one line: each new line is a new record
- The comma in this case is called the __'delimiter'__ as it shows the difference (or limit) between one value and the next.
- Other common delimiters are semi-colons and tabs (also called __tsv/tab-separated values__).
- We must be careful to check what exactly the delimiter is, as a common error is reading in a file with the wrong delimiter, and so getting a weird representation in your data.
- CSVs can also be read by Excel.
<p style="font-size:10.5px">
Usually if you are using data from mainland European countries (France/Spain etc) they will use semi-colons, hence some people prefer <i>character</i>-separated values for CSV.
</p>

### Open CSV files

Python counts with a library called `csv` that has the needed functionalities to read and write CSV files.

We open an existing file (Salaries.csv) using a context manager, and the mode in the context manager is set to read (`r`). Then, use the reader class from csv, which will take the values in the csv and store them into a variable that becomes an iterable.
"""

import csv
with open('Salaries.csv', mode='r', newline='') as csvfile:
    reader = csv.reader(csvfile, delimiter=',')
    for n, row in enumerate(reader):
        print(','.join(row))
        if n == 5: # Read only the first five entries
            break

"""### Create CSV files

The same library can be used to generate csv files. The only thing you need to change is the mode argument in the context manager is write (`w`). If you want to append things to the csv, you can use the mode append (`a`)

As opposed to reading a CSV file, if we write a CSV, we need to use the `writer` class, which will point to the file we want to create. Notice that the file we want to generate doesn't necessarily have to exist (if it exists, it will overwrite its content)

The `writer` object has some methods to create a new file. The most common one is `writerows`, which accepts iterables as arguments, and parse them into a comma separated row

So, if we define a list:
"""

my_list = [['Sparky', 7, 'Brown', 'Corgi'], ['Fido', 4, 'White', 'Husky']]

"""We can create a new csv file where each row contains the characteristic of each dog"""

import csv
with open('Dogs.csv', 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerow(['Name', 'Age', 'Colour', 'Breed'])
    writer.writerows(my_list)

"""Notice the difference between `writerow` and `writerows`. Try running the following cell and see if you see any difference between both files"""

with open('Dogs_2.csv', 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerow(['Name', 'Age', 'Colour', 'Breed'])
    writer.writerow(my_list)

"""## JSON

> <font size=+1> JSON (JavaScript Object Notation) is a file format that stores data in a way that is easily readable by both humans and machines.</font>

- It is as useful way for a browser and a server to exchange data, so it is used extensively in Web-based applications of coding.
- In fact, Jupyter Notebook .ipynb files are actually stored in JSON format.

JSON format is very similar to Python dictionaries, they contain a key and it has a corresponding value to that key

### Read JSON files

Python offers a library called `json` that can read, write, or append elements from or to a JSON file

The syntax is very similar to the one for CSV files. We use a context manager, set the mode we want to use, and then use a method. In this case, for reading a file, we use the `load` method
"""

import json
with open('JSON_sample.json', mode='r') as f:
    json_dict = json.load(f)

print(json_dict)

"""Observe that, whatever we read, is a dictionary"""

type(json_dict)

"""### Create JSON files

We can create json files from dictionaries. Observe that the mode of the context manager is `w`. The method in this case is `dump`. The `dump` method accepts the data we want to use, and then the file we want to dump the data into.
"""

test_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
with open('JSON_test.json', mode='w') as f:
    json.dump(test_dict, f)

"""Observe in your directory that now you have a `json` file called `JSON_test.json`

We can also have a string containing a json and parse it
"""

x =  '{"name": "John", "age": 30, "city": "New York"}'

y = json.loads(x)
print(y)
print(type(y))

"""Be careful with the double quotes! If your keys have single quotes, the json parser will not work!"""

x =  "{'name': 'John', 'age': 30, 'city': 'New York'}"
y = json.loads(x)

"""We do the opposite (from dictionary to JSON string) using the `dumps` method"""

test_dict = {'a': 3, 'b': 4}
new_json = json.dumps(test_dict)
print(new_json)

"""# YAML

YAML is a data serialisation language, which means that it is a common language across different applications. In fact, you already saw a serialisation language in this lesson: JSON.

> <font size=+1> YAML (YAML Ain't Markup Language) is a data serialisation language </font>

The main advantage of YAML is that is highly human-readable. You can see a comparison between JSON and YAML containing the same information.
### YAML:
```
simple-property: a simple value

object-property:
    first-property: first value
    second-property: second value

array-property:
    - item-1-property-1: one
      item-1-property-2: 2
    - item-2-property-1: three
      item-2-property-2: 4
```

### JSON
```
{
  "simple-property": "a simple value",

  "object-property": {
      "first-property": "first value",
      "second-property": "second value",
  },

  "array-property": [
      { "item-1-property-1": "one",
        "item-1-property-2": 2 },
      { "item-2-property-1": "three",
        "item-2-property-2": 4}
  ]
}
```

Observe that the base of YAML files lies in the indentation and the linespaces.

The most basic syntax in a YAML file is the __key:value__ pair
```
key: value
```
For example:
```
# This is a comment
name: Ivan
surname: 'Ying'
role: "Instructor"
IQ: 0
```
Notice that strings can be either into double quotes, single quotes or nothing, and they will work the same.

Another useful way of using YAML files is leveraging __objects__ simply by indenting the key:value pairs:
```
# This is a comment
Person:
    name: Ivan
    surname: 'Ying'
    role: "Instructor"
    IQ: 0
```
Same as with Python, indentation should be at the right level, and it would be a good idea to have a linter for checking it.

You can look for `docs-yaml` in your Extensions tab on VSCode to install a linter to tell you whether your YAML file is well indented or not. Or you can also visit [this link](https://codebeautify.org/yaml-validator)

One more thing you can use in YAML files are lists. List can contain single values, or it can also contain key:value pair values
```
Person:
    - name: Ivan
      surname: 'Ying'
      role: "Instructor"
      IQ: 0
    - name: Not Ivan
      surname: 'Gniy'
      role: "Doppelganger"
      IQ: 150
Animals:
    - Cat
    - Dog
    - Shoebill
    - Kakapo
```
The last list can also be written as:
```
Animals: [Cat, Dog, Shoebill, Kakapo]
```

### Read YAML files

Python doesn't have a library for reading YAML files. But not to worry, you can install a library that allows you to do so. The library is named `PyYAML`.
"""

!pip install PyYAML

"""Be careful, some libraries don't have the same name as they are published with. In this case, if you want to use the PyYAML library, you simply need to import `yaml`

Like CSVs and JSONs, we might want to use a context manager with the read mode
"""

import yaml
with open('yaml_example.yaml', 'r') as stream:
    data_loaded = yaml.safe_load(stream)

print(type(data_loaded))

"""Observe that, same as with JSON files, we obtain a dictionary. Let's print it out:"""

print(data_loaded)
print(data_loaded.keys())

"""Notice that we have two main keys, 'Person', and 'Animal'. The value corresponding to 'Person' is a list with dictionaries, and the value corresponding to 'Animal' is just a regular list

So we can get the values of it by indexing the correct key and/or index
"""

print(f"The first element of Person is: {data_loaded['Person'][0]}")
print(f"The name of the first element of Person is: {data_loaded['Person'][0]['name']}")
print(f"The second element of Person is: {data_loaded['Person'][1]}")
print(f"The name of the second element of Person is: {data_loaded['Person'][1]['name']}")
print(f'The value corresponding to Animals is: {data_loaded["Animals"]}')

"""### Create YAML files

You can also create YAML using the same library. The variable you need to use to create a YAML file is a dictionary. So, let's define a simple dictionary out of a JSON file we have, and then create a YAML from there
"""

import json

with open('JSON_sample.json', mode='r') as f:
    my_dict = json.load(f)

print(my_dict)

"""Now, we can use the `dump` method to save the dictionary as a yaml file. The `dump` method accepts the data we want to use, and then the file in which we want to dump our data"""

with open('YAML_from_JSON.yaml', 'w') as f:
        yaml.dump(my_dict, f)

"""# Key Takeaways

- Some popular types of file formats used in industry include: CSV, JSON, YAML, images, videos and audio
- Python provides different ways to read and write data for each of the above-mentioned file types
- CSV (comma separated value) files are those which contain rows and columns of data, with each line separated by a comma from the next
- JSON (JavaScript object notation) files are those which store data in a key-value pair that is easily read by humans. It's widely used in web applications.
- YAML (Ain't Markup Language) is a data serisalisation language which is easily readable by humans. It also stores data in key-value pairs (similar to JSON).
"""