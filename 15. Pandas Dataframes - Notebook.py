# -*- coding: utf-8 -*-
"""Notebook.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/AI-Core/Content-Public/blob/main/Content/units/Data-Handling/2.%20Data%20Manipulation%20with%20Pandas/1.%20Pandas%20Dataframes/Notebook.ipynb

# 1. Pandas - Concepts and Dataframe Operations

## Learning Objectives

- Understand the nature of Pandas series and dataframes
- Know how to index and slice Pandas dataframes columns to return dataframes and series

## Pandas

- Pandas, along with Numpy, are probably the most important libraries for Python data science activities
- The main Pandas object is a _dataframe_,  which is used to store data into rows and columns. There are also series objects, but we will not really cover them here
- The best way to think of Pandas is to consider it as a very powerful version of Excel, and a dataframe is like a spreadsheet
- Each column of a dataframe object is a Pandas _series_ object
- A Pandas series object is built from a Numpy array (series is like an array but with labelled index)
- We import using the following syntax by convention:
"""

import pandas as pd

# Do not worry about this, here we are just reading in a dataset to demonstrate operations
sf_sal = pd.read_csv('https://aicore-files.s3.amazonaws.com/Foundations/Data_Formats/Salaries.csv')
sf_sal

"""The next cell is not important, it will simply create a list of combinations of two letters. We will use it as an index just to show you how to set indices to a Pandas dataframe"""

# again do not worry about this cell, it is just creating a list of 2-letter alphabetical codes

import string
alphabet = string.ascii_uppercase
alphabet

index_list = []

for first in alphabet:
    for second in alphabet:
            index_list.append(first + second)

print(index_list)

"""So, as mentioned, we are going to use these letters as the indices for the `salaries` dataset"""

sf_sal["Id"] = index_list
sf_sal.set_index("Id", inplace=True)
sf_sal
sf_sal.to_csv('data.csv')

# Here we are just reading in a dataset to demonstrate operations.
sf_sal = pd.read_csv('https://aicore-files.s3.amazonaws.com/Foundations/Data_Formats/Salaries.csv', index_col='Id')
# Notice that we set the index to be the 'Id' column. Try to remove that argument and see what happens!
sf_sal

"""## Selection and Indexing

- We use square brackets to index, primarily by columns
- We can pass in a list of columns to select
- __Single bracket__ notation returns a __Pandas series__
- __Double bracket__ returns a __Pandas dataframe__.

> <font size=+1> A Pandas series is a single column of the Pandas dataframe </font>

Although a Pandas series is a single column, a single column can also be a Pandas dataframe

For example, observe the type we get by using single brackets:
"""

type(sf_sal["BasePay"])

"""And see now what happens if we use double brackets:"""

type(sf_sal[["BasePay"]])

"""A Pandas series shares many methods with a Pandas dataframe. However, when retrieving a Pandas series, it will also tell you the name, length and dtype of the column you are retrieving:"""

sf_sal["BasePay"]

"""But that doesn't happen with a Pandas dataframe"""

sf_sal[["BasePay"]]

"""When you use double brackets, you can select multiple columns in the same call:"""

# selecting multiple columns requires double brackets

sf_sal[["BasePay","TotalPay"]]

"""On many occasions you might want to get information of the whole dataframe quickly. It would be very tedious computing the statistics of your dataframe manually. Luckily, Pandas has methods to get information about your dataframe called: `info()` and `describe()`.

## `info()` and `describe()`

`info()` and `describe()` give us a brief summary of the dataframe we are handling. Let's see their outputs and their differences:
"""

sf_sal.info()

sf_sal.describe()

"""Notice that `info()` gives a list of the columns with their respective number of non-null values. On the other hand, `describe()` returns statistic aggregations of the columns, giving values such as mean, standard deviation, minimum value...

But wait, the results from describe have a shorter list of the columns we actually have. Where did they go? On a closer look, there are no categorical columns. 

Take a look at this [page](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html) to know how to include those columns and run the `describe` method again to see the output.

## Lambda/Anonymous Expressions with .apply() method

If you want to apply the same function to all the values in a column, __avoid iterating through the whole dataframe!__. Pandas offers a method that is much more efficient: `apply()`. The `apply()` method takes in a function and returns a dataframe or slice with the function applied to the members of that dataframe or slice.

Here, knowing how to use `lambda` functions comes very handy. You can use these lambda functions as the argument for the method. Remember their syntax:

- `lambda input : output` (in terms of input)
- e.g. to square --> `lambda x : x**2`

For example, if you want to obtain a column with the surnames of the employees based on the column with the names, you can:
- First extract the column you want to use (`sf_sal["EmployeeName"]`)
- Implement the `apply` method on it
- Use a `lambda` function that returns the second element after splitting the name
    - For example, if the name is "Ivan Ying", split will return the following list `["Ivan", "Ying"]`
    - So, by taking the second element, we obtain "Ying"
    - Thus, the whole operation would look like `"Ivan Ying".split()[1]`
- Assign the output to a column in the dataframe `sf_sal["Surname"]`
"""

sf_sal["Surname"] = sf_sal["EmployeeName"].apply(lambda x: x.split()[1])
sf_sal.head()

"""We encourage you to use lambda functions. But if you are still struggling with them, you can also use regular functions as an input for `apply`.

For example, in the next cell, we define the same function but using a regular function:
"""

def find_surname(x):
    return x.split()[1]

sf_sal["Surname"] = sf_sal["EmployeeName"].apply(find_surname)

# check head to see if it worked
sf_sal.head()

"""You can also create other columns based on different conditions. For example, let's say that we want to check all those samples that have the word "POLICE" in their `JobTitle`.

You can:
1. Create a function that returns `True` if the word "POLICE" is in the string
2. Use that function as an argument in `apply()`
3. Use it on the `JobTitle` column
4. Assign the output to a new column
"""

# define function to find 'police' first

def find_police(x):
    return "POLICE" in x


# use apply to search for it in JobTitle
sf_sal["isPolice"] = sf_sal["JobTitle"].apply(find_police)

sf_sal[["JobTitle", "isPolice"]]

"""And now you can check how many "POLICE" we have in the dataframe"""

# sum
sf_sal["isPolice"].sum()

"""### Try it out

Using what you have learnt about `apply`, how many employees have a surname starting with the letter "A"?

# Key Takeaways

- Pandas and Numpy are two of the most important libraries for Python. They are used often for data engineering and data science tasks.
- The main Pandas object is called a _dataframe_. It is used to store data into rows and columns, similar to how a relational database stores data
- A _series_ is a column within a dataframe. It is built from a Numpy array and contains a labelled index.
- We can use square brackets to index columns. A single bracket `[]` returns a series, while a double bracket `[[]]`returns a dataframe. 
- To obtain a brief summary of a certain dataframe, we can use the `.info()` and `.describe()` commands 
- Using the `.apply()` method, we can iterate through an entire dataframe and implement a function on all the data stored without the need to use a loop

## Further reading
- More details on pandas operations are available in pandas documentation: https://pandas.pydata.org/docs/
"""